
@{
	//http://localhost:5271/stockmodel/predictphoto?pid=11
	ViewData["Title"] = "股票預測";
	TimeSpan difference = DateTime.Now.Subtract(ViewBag.result.finishdate);
	TimeSpan differenceOpp = ViewBag.result.finishdate.Subtract(DateTime.Now);
	var VarsTable = ViewBag.VarsTable;


	int finishdate = (ViewBag.result.Pprefer == 1) ? 5 : 30;
	bool isTracing = ((int)difference.TotalDays <= 0) ? true : false;
	string finishdateCountDownStr = "";

	// 製作預測前時間區間 -------------
	// var ActualPrice = ChartData.Where(x => x.StDate.CompareTo(finishdates) <= 0).OrderByDescending(x => x.StDate).FirstOrDefault().SteClose;
	var finishdates = DateOnly.Parse(ViewBag.result.finishdate.ToString("yyyy-MM-dd"));
	var BuildDates = DateOnly.Parse(ViewBag.result.PbulidTime.ToString("yyyy-MM-dd"));

	var ChartData = new List<Stock>();
	ChartData = ViewBag.result.ChartData;
	ChartData = ChartData.Where(x => x.StDate.CompareTo(finishdates) <= 0).ToList();
	var LatestNdays_ori = ChartData.Where(x => x.StDate.CompareTo(BuildDates) <= 0).OrderByDescending(x => x.StDate).Take(finishdate).OrderBy(x => x.StDate);
	var LatestNdaysAverage_ori = Math.Round((decimal)LatestNdays_ori.Average(x => x.SteClose), 2);
	string ori_timeArea = "";
	string ori_timeArea_Jtype = "";
	int i = 0;
	foreach (var item in LatestNdays_ori) {
		// original的時間區間
		if (i == 0 || i == LatestNdays_ori.Count() - 1) {
			ori_timeArea += item.StDate + ",";
			if (i == 0) {
				ori_timeArea_Jtype += item.StDate + ",";
			} else if (i == LatestNdays_ori.Count() - 1) {
				ori_timeArea_Jtype += item.StDate;
			}
		} else {
			ori_timeArea_Jtype += item.StDate + ",";
		}
		i++;
	}
	ori_timeArea = ori_timeArea.Split(",")[0] + "~" + ori_timeArea.Split(",")[1];

	// 製作目前(預測)時間區間 -------------
	var LatestNdays = ChartData.Where(x => x.StDate.CompareTo(finishdates) <= 0).OrderByDescending(x => x.StDate).Take(finishdate).OrderBy(x => x.StDate);
	var LatestNdaysAverage = Math.Round((decimal)LatestNdays.Average(x => x.SteClose), 2);
	string timeArea = "";
	string timeArea_Jtype = "";
	i = 0;
	foreach (var item in LatestNdays) {
		// LatestN的時間區間
		if (i == 0 || i == LatestNdays.Count() - 1) {
			timeArea += item.StDate + ",";

			if (i == 0) {
				timeArea_Jtype += item.StDate + ",";
			} else if (i == LatestNdays_ori.Count() - 1) {
				timeArea_Jtype += item.StDate;
			}
		} else {
			timeArea_Jtype += item.StDate + ",";
		}
		i++;

	}
	timeArea = timeArea.Split(",")[0] + "~" + timeArea.Split(",")[1];

	// 製作預期走勢 -------------
	string UorD = "";
	var PredictedData = (decimal)ViewBag.result.PredictedData;
	// var PredictedData = (decimal)33.11;

	if (LatestNdaysAverage > PredictedData) {
		//看漲
		UorD = "看空";
	} else if (LatestNdaysAverage < PredictedData) {
		UorD = "看多";
	} else {
		UorD = "看平";
	}

	// 製作實際走勢 -------------
	string UorD2 = "";
	if (LatestNdaysAverage > LatestNdaysAverage_ori) {
		// 五日_now平均大於五日_ori
		UorD2 = "看多";
	} else if (LatestNdaysAverage < LatestNdaysAverage_ori) {
		// 五日_now平均小於五日_ori
		UorD2 = "看空";
	} else {
		// 五日_now平均等於五日_ori //* 100 * ((UorD == UorD2) ? 1 : -1)
		UorD2 = "看平";
	}

	// 取得數據最大最小值 -------------
	var MaxPrice = Math.Round((decimal)ChartData.Max(x => x.SteClose), 1);
	var MinPrice = Math.Round((decimal)ChartData.Min(x => x.SteClose), 1);
	// var MaxAcc = Math.Round(((decimal)PredictedData) / (decimal)ChartData.Min(x => x.SteClose) * 100, 1);
	// var MinAcc = Math.Round(((decimal)PredictedData) / (decimal)ChartData.Max(x => x.SteClose) * 100, 1);

	// var MaxAcc = 100;
	// var MinAcc = 0;

	// 製作AccComment & 結果  -------------
	string accComment = "";
	string rltComment = "";
	bool NeedShowAcc = (int)differenceOpp.TotalDays <= Math.Round(((decimal)finishdate) / 2, 0);
	int NeedShowDays = (int)differenceOpp.TotalDays - (int)Math.Round(((decimal)finishdate) / 2, 0);
	var acc = Math.Round(((decimal)PredictedData) / ((decimal)LatestNdaysAverage) * 100, 1);
	// var normalized_acc = Math.Round(((acc - MinAcc) / (MaxAcc - MinAcc)) * 100, 2);
	var normalized_acc = (acc > 100) ? 100 - (acc - 100) : acc;
	if (NeedShowAcc) {
		accComment = "預估準確率為「" + normalized_acc + " %」。";
		rltComment = ((UorD == UorD2) ? "成功" : "失敗");
	} else {
		accComment = "待" + NeedShowDays + "日，模型穩定後，計算預估準確率。";
		rltComment = "待" + NeedShowDays + "日，模型穩定後，計算預估準確率。";
	}
	// 製作誤差計算  -------------
	var SpreadRatio = Math.Round((((decimal)PredictedData) - ((decimal)LatestNdaysAverage)) / ((decimal)LatestNdaysAverage) * 100, 1);


	// if LSTM 可能要全改寫
	bool IsNNModel = (ViewBag.result.usingModel == "LSTM" || ViewBag.result.usingModel == "FNN") ? true : false;
	decimal LatestPrice=0;
	decimal PrePredictPrice=0;
	if (IsNNModel) {
		// <finishdate 的最近close價格
		LatestPrice = (decimal)ChartData.Where(x => x.StDate.CompareTo(finishdates) <= 0).OrderByDescending(x => x.StDate).FirstOrDefault().SteClose;
		PrePredictPrice = (decimal)ChartData.Where(x => x.StDate.CompareTo(BuildDates) <= 0).OrderByDescending(x => x.StDate).FirstOrDefault().SteClose;
		UorD = (PrePredictPrice > PredictedData) ? "看空" : "看多";
		UorD2 = (LatestPrice > PrePredictPrice) ? "看多" : "看空";
		acc = Math.Round(((decimal)PredictedData) / ((decimal)LatestPrice) * 100, 1);
		normalized_acc = (acc > 100) ? 100 - (acc - 100) : acc;
		SpreadRatio = Math.Round((((decimal)PredictedData) - ((decimal)LatestPrice)) / ((decimal)LatestPrice) * 100, 1);
		if (NeedShowAcc) {
			accComment = "預估準確率為「" + normalized_acc + " %」。";
			rltComment = ((UorD == UorD2) ? "成功" : "失敗");
		} else {
			accComment = "待" + NeedShowDays + "日，模型穩定後，計算預估準確率。";
			rltComment = "待" + NeedShowDays + "日，模型穩定後，計算預估準確率。";
		}
	}

	if (isTracing) {
		// 追蹤中
		finishdateCountDownStr += "預測「追蹤中」，整體走勢「" +
		UorD + "」，參考價「" + PredictedData + "」元，" + accComment + "此預測將於「" +
		(int)differenceOpp.TotalDays + "」天後結案。";

	} else {


		var ActualPrice = ChartData.Where(x => x.StDate.CompareTo(finishdates) <= 0).OrderByDescending(x => x.StDate).FirstOrDefault().SteClose;
		finishdateCountDownStr += "預測「已結案" + (int)difference.TotalDays + "天」，預測趨勢「" + UorD +
		"」，實際「走" + UorD2.Substring(1, 1) + "」，趨勢預測「" + ((UorD == UorD2) ? "成功」" : "失敗」") + "，模型準確率為「" +
		normalized_acc + "%」";

	}

}
<!-- 引入 Chart.js 库 -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>

<style>
	

</style>
<div>

	<h1 id="cmt" style="background-color:rgba(0, 98, 234, 0.1);padding:5px;">@finishdateCountDownStr </h1>
	
	<div ><h1>模型績效</h1><div ><p>使用傳統模型(迴歸、時間序列)，參考價將以均價的方式進行預測；而類神經網路(LSTM、FNN)，參考價將以單日收盤作為預測值</p></div></div>
	
	<table class="table table-light">
		<thead>
			<tr>
				<th>預測前 時間</th>
				<th>@(isTracing ? "目前 時間" : "結案 時間")</th>
				<th>預測前 參考價(A)</th>
				<th>預測 參考價(B)</th>
				<th>目前 參考價(C)</th>
				<th>預測走勢(D, A vs B)</th>
				<th>實際走勢(E, A vs C)</th>
				<th>@(isTracing ? "預估結果(F, D vs E)" : "結案結果(F, D vs E)")</th>
				<th>@(isTracing ? "預估準確率(G, B vs C)" : "準確率(G, B vs C)")</th>
				<th>@(isTracing ? "預測誤差(H, B vs C)" : "實際誤差(H, B vs C)")</th>
			</tr>
		</thead>
		<tr>
			<td>@ori_timeArea</td>
			<td>@timeArea</td>
			<td>@((IsNNModel)?PrePredictPrice:LatestNdaysAverage_ori)</td>
			<td>@PredictedData</td>
			<td>@((IsNNModel)?LatestPrice:LatestNdaysAverage)</td>
			<td>@(UorD)</td>
			<td>@("走" + UorD2.Substring(1, 1))</td>
			<td>@(rltComment)</td>
			<td>@(isTracing ? accComment : normalized_acc + "%") </div td >
			<td>@(SpreadRatio + "%") </style td >

		</tr>
	</table>
	<h1 style="margin-top:30px">預測結果</h1>
	<table class="table table-light">
		<thead>
			<tr>
				<th>股票名稱</th>
				<th>參考價格</th>
				<th>建立時間</th>
				<th>結案時間</th>
			</tr>
		</thead>
		<tr>
			<td id="stockname"> </td>
			<td>@PredictedData</td>
			<td>@ViewBag.result.PbulidTime</td>
			<td>@ViewBag.result.finishdate</td>
		</tr>
	</table>

	<h1>模型參數</h1>
	<table class="table table-light">
		<thead>
			<tr id="HereParas_th">
				<th>使用模型</th>
				<th>投資偏好</th>
				<th>使用變數</th>
			</tr>
		</thead>
		<tr id="HereParas_td">
			<td>@ViewBag.result.usingModel</td>
			<td>@((ViewBag.result.Pprefer == 1) ? "短期投資" : "長期投資") </td>
			<td id="Pvariable"></td>

		</tr>
	</table>
	<h1>模型評估</h1>
	<table class="table table-light">
		<thead>
			<tr id="modelEva_th">
			</tr>
		</thead>
		<tr id="modelEva_tb">
		</tr>
	</table>


</div>


<div style="max-width:1200px;max-height:700px;display:block">

	<!-- 创建一个 canvas 元素用于绘制图表 -->
	@* <canvas id="stockChart" width="800" height="400"></canvas> *@
	<canvas id="stockChart" width="1200" height="600"></canvas>
</div>
@* <h1>預測股票代號: @ViewBag.result.SnCode </h1>
<br>
<h1 id="stockname"></h1>
<br />

<h1>使用模型: @ViewBag.result.usingModel</h1>
<br />
<h1>@finishdateCountDownStr，收盤價: @ViewBag.result.PredictedData</h1>
<br />
<h1>MSE-Loss: @ViewBag.result.PredictedLoss</h1>
<br />
<button id="mypredictresult">跳轉我的預測</button>
<br />
<button id="mystockid">跳轉個股</button>
<br /> *@
<script>
	
	

	var actualData = @Html.Raw(Json.Serialize(ChartData));
	var predictedData = @Html.Raw(Json.Serialize(PredictedData));

	var formattedData = actualData.map(function (item) {
		var date = moment(item.StDate).format('YYYY-MM-DD');
		return {
			x: date,
			y: item.SteClose,
			label: '日期: ' + date + ', 收盤價: ' + item.SteClose
		};
	});
	var formattedDataRemoveLast = formattedData.slice();

	formattedDataRemoveLast.pop();
	var formatDate_Ori = (@Html.Raw(Json.Serialize(ori_timeArea_Jtype)));
	// var dateObjects = formatDate_Ori.map(function (dateString) {
	// 	return new Date(dateString);
	// });
	// 去除字符串中的方括号并以逗号分割为数组
	var dateStrings = formatDate_Ori.split(",");
	var dateObjects_Ori = [];
	$.each(dateStrings, function (i, val) {
		var date = new Date(val);
		dateObjects_Ori.push(moment(date).format('YYYY-MM-DD'));
	})

	var formatDate_Lat = (@Html.Raw(Json.Serialize(timeArea_Jtype)));
	// 去除字符串中的方括号并以逗号分割为数组
	dateStrings = formatDate_Lat.split(",");
	var dateObjects_Lat = [];
	$.each(dateStrings, function (i, val) {
		var date = new Date(val);
		dateObjects_Lat.push(moment(date).format('YYYY-MM-DD'));
	})

	var lastActualDate = moment(formattedData[formattedData.length - 1].x);
	var predictedDate = moment(lastActualDate);
	var formattedPredictedDate = predictedDate.format('YYYY-MM-DD');
	var predictedClosePrice = predictedData;
	var predictedDate1 = predictedDate.format('YYYY-MM-DD')
	// console.log(typeof predictedDate1);
	// console.log(typeof formattedPredictedDate);
	var ctx = document.getElementById('stockChart').getContext('2d');

	var stockChart = new Chart(ctx, {
		type: 'line',
		data: {
			labels: [],
			datasets: [{
				label: '實際收盤價',
				data: formattedData,
				borderColor: 'blue',
				fill: false
			}, {
				label: '實際收盤價',
				data: [{
					x: formattedData[formattedData.length - 1].x,
					y: formattedData[formattedData.length - 1].y
				}],
				borderColor: 'blue',
				fill: false,
				pointRadius: 10
			}, {
				label: '預測參考價',
				data: [{
					x: formattedPredictedDate,
					y: predictedClosePrice
				}],
				borderColor: 'red',
				fill: false,
				pointRadius: 10
			}, {
				label: '趨勢線',
				data: [{
					x: formattedData[formattedData.length - 1].x,
					y: formattedData[formattedData.length - 1].y
				}, {
					x: formattedPredictedDate,
					y: predictedClosePrice
				}],
				borderColor: 'red',
				fill: false,
				pointRadius: 0,
				borderWidth: 0.5,
				borderDash: [5, 5]
			}, {
				label: '預測前' + @Html.Raw(Json.Serialize(finishdate))+'日移動平均',
				data: [{
					x: dateObjects_Ori[0],
					y: @Html.Raw(Json.Serialize(LatestNdaysAverage_ori)) // 设置水平线的 y 坐标值
													}, {
					x: dateObjects_Ori[dateObjects_Ori.length - 1],
					y: @Html.Raw(Json.Serialize(LatestNdaysAverage_ori))
													}],
				borderColor: 'black',
				fill: false,
				borderWidth: 0.7,
				borderDash: [5, 5],
				hidden: @Html.Raw(Json.Serialize(isTracing)) // 結案的話秀
													}, {
				label: '近' + @Html.Raw(Json.Serialize(finishdate))+'日移動平均*',
				data: [{
					x: dateObjects_Lat[0],
					y: @Html.Raw(Json.Serialize(LatestNdaysAverage)) // 设置水平线的 y 坐标值
													}, {
					x: dateObjects_Lat[dateObjects_Lat.length - 1],
					y: @Html.Raw(Json.Serialize(LatestNdaysAverage))
														}],
				borderColor: 'red',
				fill: false,
				borderWidth: 0.7,
				//borderDash: [5, 5],
				hidden: false // 设置水平线1隐藏
			}]
		},
		options: {
			responsive: false, // 禁用響應式
			maintainAspectRatio: false, // 禁用維持長寬比
			scales: {
				x: {
					ticks: {
						maxTicksLimit: 15 // 限制最大刻度數為 15
					}

				},
				y: {
					ticks: {
						beginAtZero: true
					}
				}
			}

		}
	});

	$("#mypredictresult").on("click", function () {
		window.location.href = "/Member/MyPredictResult"
	})
	$("#mystockid").on("click", function () {
		window.location.href = "/Home/StockCharts/" + @ViewBag.result.SnCode
																									})
	$.ajax({
		url: "/StockModel/stocksnamewithcsv",
		method: "get",
		data: { data: @ViewBag.result.SnCode },
		success: function (e) {
			$("#stockname").text(`${@Html.Raw(Json.Serialize(ViewBag.result.SnCode))} - ${e[0]["label"]}`);

		}
	})
	function TransJtoO(DummyBlock) {

		var ToJ = JSON.parse(DummyBlock);
		// console.log(ToJ);
		var eva = new Object();
		var pars = new Object();
		// var keys = Object.keys(ToJ);
		// console.log(keys[0]);
		$.each(ToJ, function (i, val) {
			if (i == "MSE") {
				eva.均方誤差 = val;
			} else if (i == "RMSE") {
				eva.均方根誤差 = val;
			} else if (i == "Iters") {
				pars.迭代數 = val;
			} else if (i == "uEsti") {
				pars.誤差上界 = val;
			} else if (i == "lEsti") {
				pars.誤差下界 = val;
			} else if (i == "wSize") {
				pars.視窗尺寸 = val;
			} else if (i == "sLen") {
				pars.系列尺寸 = val;
			} else if (i == "tSize") {
				pars.資料筆數 = val;
			} else if (i == "cLev") {
				pars.信心水準 = val;
			} else if (i == "Layerchoose") {
				pars.神經層數 = val;
			}
			// console.log(i+" = "+val);
		})
		// console.log(eva);
		// console.log(pars);
		var EvaOrPar = new Object();
		EvaOrPar.eva = eva;
		EvaOrPar.pars = pars;
		// console.log(EvaOrPar);

		var isTracing = @Html.Raw(Json.Serialize(isTracing));
		var acc = @Html.Raw(Json.Serialize(normalized_acc));
		if (isTracing) {
			eva.預計準確率 = (acc) + "%";
		} else {
			eva.準確率 = (acc) + "%";
		}
		$("#HereParas").text(JSON.stringify(pars));

		// 把變數轉成中文顯示
		var varsMapTableJ = @Html.Raw(Json.Serialize(VarsTable));
		var PvariableJ = @Html.Raw(Json.Serialize(ViewBag.result.Pvariable));
		var varsMapTable = JSON.parse(varsMapTableJ);
		var Pvariable = JSON.parse(PvariableJ);

		var TradVars = "";
		var k = 0;
		$.each(varsMapTable, function (i, ival) {
			for (var j = 0; j < Pvariable.length; j++) {
				if (i == Pvariable[j]) {
					if (k == 0) {
						TradVars = ival + ', ';
					}
					else if (k == Pvariable.length - 1) {
						TradVars += ival;

					} else {
						TradVars += ival + ', ';

					}
					k++;
				}

			}
		})
		// console.log(`${TradVars}`);
		$("#Pvariable").text(TradVars);


		$.each(eva, function (i, val) {
			if (i == "預計準確率" || i == "準確率") { } else {
				$("#modelEva_th").append("<th>" + i + "</th>");
				$("#modelEva_tb").append("<td>" + val + "</td>");
			}
		})
		$.each(pars, function (i, val) {
			$("#HereParas_th").append("<th>" + i + "</th>");
			$("#HereParas_td").append("<td>" + val + "</td>");
		})
		return EvaOrPar;
	}
	TransJtoO(@Html.Raw(Json.Serialize(ViewBag.result.PredictedLoss)));

</script>
